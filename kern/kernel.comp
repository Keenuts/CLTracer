#define GEN_SWAP(Type)        \
static inline                 \
void swap(Type *a, Type *b) { \
  Type c = *a;                \
  *a = *b;                    \
  *b = c;                     \
}
GEN_SWAP(double);

struct scene_t {
  int width;
  int height;
  int ker_width;
  int ker_height;

  double3 camera_pos;
  double3 camera_right;
  double3 camera_up;
  double3 camera_fwd;
};

__constant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE
                             | CLK_ADDRESS_CLAMP_TO_EDGE
                             | CLK_FILTER_NEAREST;

static
bool intersect(
  double3 origin,
  double3 dir,
  double3 center,
  double r,
  double3 *pt)
{
  double3 oc;
  double d2, ch2, oh, t1, t2;
  int collide = 1;

  oc = (center - origin);
  oh = dot(oc, dir);
  collide = mix(collide, 0, (double)(oh < 0));

  ch2 = pow(length(oc), 2) - (oh * oh);
  collide = mix(collide, 0, (double)(ch2 > r * r));

  d2 = sqrt(r * r - ch2);
  t1 = oh + d2;
  t2 = oh - d2;
  if (t1 > t2)
    swap(&t1, &t2);
  t1 = mix(t1, t2, (double)(t1 < 0));
  collide = mix(collide, 0, (double)(t1 < 0.));

  *pt = origin + dir * t1;
  return collide;
}

#define FOV 45.0
#define PI 3.14159265358979323846
#define DEG2RAD 0.017453292519943295

static
double3 compute_ray(struct scene_t scene, int2 pos) {
  double width, height, L, t_width, t_height;
  double3 center, pt;

  width = scene.width;
  height = scene.height;

  L = width / (tan(DEG2RAD * (FOV * 0.5)) * 2.);
  center = scene.camera_pos + scene.camera_fwd * L;

  t_width = mix(-width, width, pos.x / width) * 0.5;
  t_height= mix(-height, height, pos.y / height) * 0.5;

  pt = scene.camera_right * t_width
            + scene.camera_up * t_height
            + scene.camera_fwd
            + center;
  return normalize(pt - scene.camera_pos);
}

__kernel void raytracer(
  __constant struct scene_t *p,
  __write_only image2d_t output
)
{
  const double3 sun_dir = normalize((double3)(-0.3, 0.8, 0.5));
  const float3 sky_color = (float3)(240, 248, 255);
  const float3 sphere_color = (float3)(155, 255, 0);

  const double3 sphere_o = (double3)(0.0f, 0.0f, 0.0f);
  const double sphere_r = 2.0;

  const int2 pos = (int2)(
                 get_global_id(0) * p->ker_width, get_global_id(1) * p->ker_height);

  for (int y = 0; y < p->ker_height; y++) {
    for (int x = 0; x < p->ker_width; x++) {
      bool touch;
      double3 look_d, normal, pt;
      float3 color;

      int2 local_pos = (int2)(pos.x + x, pos.y + y);

      look_d = compute_ray(*p, local_pos); 
      touch = intersect(p->camera_pos, look_d, sphere_o, sphere_r, &pt);
      normal = normalize(pt - sphere_o);

      color = sphere_color * clamp((float)dot(normal, -sun_dir), 0.0f, 1.0f);
      color = mix(sky_color, color, touch);

      uint4 albedo = (uint4)(color.x, color.y, color.z, 255);
      write_imageui(output, local_pos, albedo);
    }
  }
}
